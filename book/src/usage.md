# Usage

This guide covers how to install, configure, and use VarveDB in your Rust application.

## Installation

Add `varvedb` to your `Cargo.toml`:

```toml
[dependencies]
varvedb = "0.1" # Check crates.io for the latest version
rkyv = { version = "0.7", features = ["validation"] }
tokio = { version = "1", features = ["full"] }
```

## Defining Events

Events in VarveDB must be serializable by `rkyv`. You need to derive `Archive`, `Serialize`, and `Deserialize`.

```rust
use rkyv::{Archive, Serialize, Deserialize};

#[derive(Archive, Serialize, Deserialize, Debug, Clone)]
#[archive(check_bytes)]
pub struct MyEvent {
    pub id: u32,
    pub action: String,
    pub timestamp: u64,
}
```

## Initialization

To start, you need to open the storage engine.

```rust
use varvedb::storage::{Storage, StorageConfig};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let config = StorageConfig {
        path: "./data".into(),
        encryption_enabled: true,
        master_key: Some([0u8; 32]), // In production, load this from a secure location!
        ..Default::default()
    };
    
    let storage = Storage::open(config)?;
    Ok(())
}
```

## Writing Events

Use the `Writer` to append events to a stream.

```rust
use varvedb::engine::Writer;

// ... storage initialization ...

let mut writer = Writer::<MyEvent>::new(storage.clone());

// Append an event to stream "user-123", expecting it to be empty (version 0)
let event = MyEvent { id: 1, action: "login".into(), timestamp: 1600000000 };
writer.append("user-123", 0, event)?;
```

## Reading Events

Use the `Reader` to access events.

```rust
use varvedb::engine::Reader;

// ... storage initialization ...

let reader = Reader::<MyEvent>::new(storage.clone());
let txn = storage.env.read_txn()?;

// Read the first event (global sequence 1)
if let Some(event) = reader.get(&txn, 1)? {
    println!("Event: {:?}", event);
}
```

## Processing Events

To process events in real-time, implement the `EventHandler` trait and use the `Processor`.

```rust
use varvedb::engine::{Processor, EventHandler};
use varvedb::ArchivedMyEvent; // Generated by rkyv

struct MyHandler;

impl EventHandler<MyEvent> for MyHandler {
    fn handle(&mut self, event: &ArchivedMyEvent) -> varvedb::error::Result<()> {
        println!("Handling event: {:?}", event);
        Ok(())
    }
}

// ... inside async runtime ...

let rx = writer.subscribe();
let mut processor = Processor::new(reader, MyHandler, "my-consumer-group", rx);

// This will run indefinitely, processing new events as they arrive
processor.run().await?;
```
